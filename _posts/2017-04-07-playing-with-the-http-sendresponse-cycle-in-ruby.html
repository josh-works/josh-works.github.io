---
layout: post
title: Playing with the HTTP send/response cycle in Ruby, without Faraday
categories:
- programming
tags:
- ruby
- gists
- turing
status: publish
type: post
published: true
meta: {}
---
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><em>author's note (that's me): I've written a lot over the last few months of Turing, but my <a href="https://gist.github.com/josh-works">list of public gists</a> is getting so long I can barely keep track of it. So, as I write longer things that I think might be useful to others (especially Turing students) I'm going to stick it here. If you're not interested in Turing or programming, it's safe to skip this particular post</em></p>
<p><em>Also, I wrote this originally in github-flavored markdown. Seems to play poorly with this Markdown editor. Some syntax highlighting may be off, but the code itself isn't that important. Playing with Curl and NetCat in the terminal is where all the fun happened. Apologies for readability challenges. <a href="https://gist.github.com/josh-works/e02242b959f0422077c801cef02ab838">Here's the original on github</a></em></p>
<p>The following is part of the <a href="http://backend.turing.io/module1/projects/http_yeah_you_know_me">HTTP Server</a> project.</p>
<p>First, I'm working through <a href="http://practicingruby.com/articles/implementing-an-http-file-server">Practicing Ruby's "Implementing an HTTP File Server"</a> for general practice and understanding.</p>
<p>I'm going to use <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en">Postman</a> to capture traffic and try to replicate some of the things the guides reference.</p>
<p><strong>Lastly, I just found Jeff Casamir's walkthrough of almost everything I've discovered in the last week. Save yourself the time, and go read <a href="https://github.com/turingschool/curriculum/blob/master/source/projects/http_yeah_you_know_me-addendum.markdown">it here</a></strong></p>
<h2 id="finding-get-requests-responses-in-the-wild">Finding GET requests/responses in the wild</h2>
<p>First, I need to configure postman to show request/response headers, like what the guides indicate:</p>
<pre><code># HTTP Request
GET /file.txt HTTP/1.1
User-Agent: ExampleBrowser/1.0
Host: example.com
Accept: */*

# HTTP Response
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 13
Connection: close

hello world</code></pre>
<p>Turns out Postman cannot do this caputuring by default. </p>
<p>So, follow <a href="http://stackoverflow.com/questions/33793629/postman-how-to-see-request-with-headers-and-body-data-with-variables-substitut">these instructions</a> (to enable <code>right_click &gt; inspect</code> within Postman</p>
<p>Lets first look at some get requests in the wild:</p>
<p>Using Postman, I made a get request for <code>turing.io</code>. I get back lots of HTML, etc. But I want to see the headers. The "Headers" tab in the Postman request isn't really helpful.</p>


      <img src="/squarespace_images/static_556694eee4b0f4ca9cd56729_56035dbbe4b07ebf58d79d16_58e71e5b725e255284d9729c_1491541612037__img.jpg_" alt="">


<p>So, we'll look at "network traffic" per the following:</p>
<p>right click inside postman &gt; "inspect" &gt; Network tab &gt; "clear" the screen, if anything is in it, &gt; switch back to postman, re-send the GET request &gt; switch back to "inspect window".</p>
<p>Looks like this:</p>


      <img src="/squarespace_images/static_556694eee4b0f4ca9cd56729_56035dbbe4b07ebf58d79d16_58e71ec81b631b9312d85a73_1491541748713__img.gif_" alt="">


<p>OK, cool. This stuff looks promising: </p>

      <img src="/squarespace_images/static_556694eee4b0f4ca9cd56729_56035dbbe4b07ebf58d79d16_58e71f2420099ea651601e3e_1491541800899__img.jpg_" alt="">


<p>Everything I highlighted corresponds to items mentioned in the instructions. This is approaching "interesting", and I feel like there might be an insight around the corner. </p>
<h2 id="setting-up-my-own-requests-in-ruby-seeing-headers-in-postman">Setting up my own requests in Ruby, seeing headers in Postman</h2>
<p>So, I can find the headers for any GET request I might make in the wild, so now I'm going to try to do the same setup with my own little ruby server, per <a href="http://practicingruby.com/articles/implementing-an-http-file-server">this guide</a>.</p>
<p>I'm following the author's instructions to:</p>
<blockquote>
<p>To begin, let’s build the simplest thing that could possibly work: a web server that always responds “Hello World” with HTTP 200 to any request</p>
</blockquote>
<p>I'm writing everything in the http_yeah_you_know_me directory. I'll delete it before pushing a final project version to Github. </p>
<pre><code>require 'socket'

server = TCPServer.new('localhost', 2345)</code></pre>
<p>Turns out TCPServer is a <a href="http://ruby-doc.org/stdlib-2.4.0/libdoc/socket/rdoc/TCPServer.html">Ruby class</a>, just like an enumerable or array or hash or Fixnum or NilClass, etc. Cool.</p>
<p>It's got some methods that I won't worry about right now.</p>
<p>Moving on:</p>
<pre><code>loop do
  socket = server.accept
  request = socket.gets

  STDERR.puts request

  response = "Hello World!\n"

  socket.print "HTTP/1.1 200 OK\r\n" +
               "Content-Type: text/plain\r\n" +
               "Content-Length: #{response.bytesize}\r\n" +
               "Connection: close\r\n"</code></pre>
<p>The loop seems interesting. I tested the simple_server.rb file before writing this, and it seemed that the socket closed as soon as a single request was made. (I.E. I'd start the "server", and as soon as I interacted with it in any way, it would do something and close. So I wonder if this loop will keep the server open. </p>
<p>Please read through the commented version of what I'm writing above. It's a good explenation, but I've noticed something interesting. We're printing a HTTP Response. See the <code>HTTP/1.1 200OK</code> in the first line? Does that look familiar?</p>
<p><img src="https://cl.ly/3k3U291S0A3O/Developer_Tools_-_chrome-extension___fhbjgbiflinjbdggehcddcbncdddomop_html_requester_html.jpg" alt="looks like we're writing some of this header"></p>
<pre><code>socket.print "\r\n"
  socket.print response
  socket.close
end</code></pre>
<p>That first line is, according to the comments, the required new-line to tell the server (or something) that the header is over and the body content is coming. The response references a previously defined variable of <code>response = "Hello World!\n"</code>, so we're printing <code>hello world</code> as the content. </p>
<p>Lets try to fire this thing up. Save file, run as a program from the command line, and visit <code>http://localhost:2345/anything</code>. </p>
<p>Looks like it worked:</p>
<p><img src="https://cl.ly/1s2Y2X053e3y/localhost_2345_anything.jpg" alt="printed to the browser"></p>
<p>But it's not very exciting. Lets get back into Postman and try to dig deeper:</p>
<p>Now we're getting more. I can see every parameter passed through to the server, <em>and it is staying open</em>! (Put a flag in that. The "simple server" we made for HTTP_yeah_you_know_me can be kept open with a loop. Cool.</p>


      <img src="/squarespace_images/static_556694eee4b0f4ca9cd56729_56035dbbe4b07ebf58d79d16_58e71fc5725e255284d9c329_1491542006921__img.gif_" alt="">


<p>And, as the author mentioned in the tutorial, this seems to be working:</p>
<pre><code># Log the request to the console for debugging
  STDERR.puts request</code></pre>
<p><img src="https://cl.ly/1c3d1V1Q0i2Q/1____turing_module1_projects_http_yeah_you_know_me_experiments__ruby_.jpg" alt="STDERR printed to screen. I bet this is useful for later"></p>
<p>And, as recommended, open up another window and run <code>curl --verbose -XGET http://localhost:2345/anything_you_want_to_put_here</code></p>
<p>I like to understand shell commands when I run them, so if you look at the MAN pages for <code>curl</code>, you can find what each of those flags means.</p>
<p><code>curl --verbose</code> means "curl talks a lot", and more importantly, lines beginning with <code>&gt;</code> is <em>header data sent by curl</em>, and lines beginning with <code>&lt;</code> data-preserve-html-node="true" data-preserve-html-node="true" data-preserve-html-node="true" data-preserve-html-node="true" data-preserve-html-node="true" is <em>header data received by curl</em>. Lines beginning with <code>*</code> is additional info added by CURL.</p>
<p>I suspect this will be important.</p>
<p><code>-XGET</code> is a flag that, according to the MAN page, "specifies custom request method". the <code>-X</code> lives by itself, and whatever follows is what it makes as the request method, so <code>-XGET</code>, <code>-XPOST</code>, and <code>-XDELETE</code> are all probably valid uses of the flag.</p>
<p>Here's the output for <code>curl --verbose -XGET htpp://localhost:23454/whatever_blah_blah_blah</code></p>
<pre><code>[experiments (setup)]$ curl --verbose -XGET http://localhost:2345/whatever_blah_blah_blah
Note: Unnecessary use of -X or --request, GET is already inferred.
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 2345 (#0)
&gt; GET /whatever_blah_blah_blah HTTP/1.1
&gt; Host: localhost:2345
&gt; User-Agent: curl/7.52.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Content-Length: 13
&lt; Connection: close
&lt;
Hello World!
* Curl_http_done: called premature == 0
* Closing connection 0</code></pre>
<p>Cool. We've got data sent by curl (prepended with <code>&gt;</code>), data received (prepended with <code>&lt;</code>), data-preserve-html-node="true" data-preserve-html-node="true" data-preserve-html-node="true" data-preserve-html-node="true" data-preserve-html-node="true" what is actually passed through (the one line without any characters at the beginning) and of course, additional data returned by CURL. (begins with <code>*</code>).</p>
<p>Phew. Learning some stuff, eh? I still don't know what most of this means, but it's building out a mental model. So, keep experimenting. You're typing all these commands yourself, right? no copy-pasta from here. That'll keep you from learning as much.</p>
<h2 id="congrats-">Congrats!</h2>
<p>This is the end of the first section of the post, building a simple server. Now, moving along, gonna build a more complex one. </p>
<p>This is where I look over my notes, take a walk, and get some coffee. This is a lot of work, so let it sink in and consolidate. </p>
<h1 id="serving-files-over-http">Serving files over HTTP</h1>
<p>I'm now working through the second half of <a href="http://practicingruby.com/articles/implementing-an-http-file-server">this tutorial</a>.</p>
<p>He says:</p>
<blockquote>
<p>For each incoming request, we’ll parse the <code>&gt; &gt; &gt; &gt; Request-URI</code>&gt; &gt; &gt; &gt; header and translate it into a path to a file within the server’s public folder.</p>
</blockquote>
<p>What's the request URI? How's it different from a URL? I'm not sure, but I can infer some things. Mostly, looking at some of the results of poking around in different pages in Postman, and looking at the results, I think we can figure this out. (Googling around for "URI vs URL didn't help a lot)</p>
<p>We know that the first line of a HTTP Request looks like this: <code>GET / HTTP/1.1</code>. This is three things:</p>
<ol>
<li>GET is the method.</li>
<li>/ is the "path"</li>
<li>HTTP/1.1 is the protocal (or possibly called the "scheme").</li>
</ol>
<p>So, if I go to the root of a website (like www.turing.io) the header will be: <code>GET / HTTP/1.1</code>. </p>
<p>If I go to a specific page (or <em>resource</em>) I'll go to www.turing.io/our-team. What do you think the GET request would look like then? Here's my guess:</p>
<p><code>GET /our-team HTTP/1.1</code></p>
<p>Lets fire it up in POSTMAN and see:</p>
<p><img src="https://cl.ly/2s3P2z1e0J40/Developer_Tools_-_chrome-extension___fhbjgbiflinjbdggehcddcbncdddomop_html_requester_html.jpg" alt="looks promising"></p>
<p>Cool. So the path is just <code>website.com/&lt;the_path&gt;</code>. Or, to tie it into ruby-speak, when we <code>require</code> another file, we define its from the root directory. Similar idea with the URI.</p>
<p>Onward.</p>
<p>First bit of code in the second file. (I'd start a new file from scratch, and type every line...)</p>
<pre><code>require 'socket'
require 'uri'

WEB_ROOT = './public'

CONTENT_TYPE_MAPPING = {
  'html' =&gt; 'text/html',
  'txt' =&gt; 'text/plain',
  'png' =&gt; 'image/png',
  'jpg' =&gt; 'image/jpeg'
}

DEFAULT_CONTENT_TYPE = 'application/octet-stream'</code></pre>
<p>Makes sense, except I have no idea what an <code>octet-stream</code> is. Don't really care, though. This just is mapping input values to something that our HTTP server can understand, I believe.</p>
<pre><code>def content_type(path)
  ext = File.extname(path).split(".").last
  CONTENT_TYPE_MAPPING.fetch(ext, DEFAULT_CONTENT_TYPE)
end</code></pre>
<p>We've seen <code>File.extname</code> before, when doing FileIO stuff. So this is taking the file extension, splitting it from the file name, and trying to match it to the hash we just wrote. If it matches, it'll pull and do something with the matching value. I.E. <code>jpg</code> =&gt; <code>image/jpeg</code>. </p>
<p>Onward, a bunch of other stuff that is explained in the commented out portions of the tutorial, and I barely understand it, so skipping them.</p>
<p>We see this again:</p>
<p>(You typed it out by hand, right?)</p>
<pre><code>loop do

  socket = server.accept
  request_line = socket.gets

  STDERR.puts request_line

  path = requested_file(request_line)

  if File.exist?(path) &amp;&amp; !File.directory?(path)
    File.open(path, "rb") do |file|
      socket.print "HTTP/1.1 200 OK\r\n" +
                  "Content-Type: #{content_type(file)}\r\n" +
                  "Content-Length: #{file.size}\r\n" +
                  "Connection: close\r\n"

      socket.print "\r\n"

      IO.copy_stream(file, socket)
    end

  else
    message = "File not found\n"

    socket.print "HTTP/1.1 404 Not Found\r\n" +
                "Content-Type: text/plain\r\n" +
                "Content-Length: #{message.size}\r\n" +
                "Connection: close\r\n"

    socket.print "\r\n"

    socket.print message
  end</code></pre>
<p>I was curious about all the <code>\r\n</code> characters. It's obviously something to do with a line break. </p>
<p>On <a href="http://stackoverflow.com/questions/4415654/which-line-break-in-php-mail-header-r-n-or-n">stack overflow</a>, I found this:</p>
<blockquote>
<p>The CRLF <code>&gt; &gt; &gt; &gt; \r\n</code>&gt; &gt; &gt; &gt; , should be used according to the php documentation. Also, to conform to the RFC 2822 spec lines must be delimited by the carriage return character, CR <code>&gt; &gt; &gt; &gt; \r</code>&gt; &gt; &gt; &gt; immediately followed by the line feed, LF <code>&gt; &gt; &gt; &gt; \n</code>&gt; &gt; &gt; &gt; .</p>
</blockquote>
<p>Seems like it's a <em>Carriage Return Line Feed</em> symbol, native to PHP, that inserts a really "hard" line break. That makes since, since earlier in the guide, the author mentioned that HTTP request/responses are very sensitive to line breaks and white spaces. So, I'm flagging this as "important" for later use.</p>
<p>And, keep following the instructions. I got it to serve up an /index.html page by default, and downloaded a few other files that I "stored" in a public directory in the same place as the server-generation script. </p>
<p>So, I feel like I've got my head a little more wrapped around server stuff in Ruby. Writing it out helps me a bit, maybe will be helpful to others, too.</p>
<h1 id="play-around-with-building-your-own-http-response-live-">Play around with building your own HTTP Response - LIVE!</h1>
<p>I'm keeping notes for myself and my own understanding - I'm not good at teaching that which I barely can wrap my head around, so... I apologize for the upcoming disconnectedness or holes in reasoning.</p>
<p>I've really, realy wanted to get a tool up and running that lets me talk, as a server, to something that's expecting a given response. This is so I can get one level of abstraction lower to understand these HTTP requests/responses.</p>
<p>I just figured out how to do it.</p>
<p>We'll use two tools, both already existing in your terminal:</p>
<ol>
<li>nc (Stands for "Net Cat")</li>
<li>CURL (stands for C-URL? "see URL"?)</li>
</ol>
<p>I strongly recommend downloading and installing <a href="https://github.com/tldr-pages/tldr">tldr</a>, as it will let you more quickly explore terminal commands. We'll be using "flags" for both the above utilities. (a flag makes a program do something other than it's default. Like <code>ls</code> vs <code>ls -l</code>)</p>
<p>You'll need two terminal windows side by side, like this:</p>
<p><img src="https://cl.ly/0Y0K180V0Q3q/1____turing_module1_projects_http_yeah_you_know_me__nc_.jpg" alt="side by side"></p>
<p>On the left is netcat, on the right is CURL.</p>
<p>I started the <code>nc</code> command on the left with <code>nc -l 9090</code>. If you're reading this, please, please install the <code>tldr</code> tool and run (in your terminal) <code>tldr nc</code>.</p>
<p>Now, look up what <code>-l</code> does. </p>
<p>On the right, I've got CURL, running as <code>curl -v localhost:9090</code>. Look it up in TLDR, tell me what -v does. (Hint, i've outlines it above.)</p>
<p>Here's using them in tandem: </p>

      <img src="/squarespace_images/static_556694eee4b0f4ca9cd56729_56035dbbe4b07ebf58d79d16_58e7206f9de4bb42e72e3e5b_1491542143058__img.gif_" alt="">


<p>You can write, line by line, your own valid header. You'll notice it ends whenever you add a new-line character, and when you DO try to send actual content, if you get the "content-length" figure wrong, it'll cut you off.</p>
<p>example: </p>

      <img src="/squarespace_images/static_556694eee4b0f4ca9cd56729_56035dbbe4b07ebf58d79d16_58e7209e59cc682cc93f0068_1491542210292__img.gif_" alt="">


<h1 id="i-want-to-talk-to-my-ruby-program-now">I want to talk to my ruby program now</h1>
<p>I feel lik I can use Netcat to impersonate a client (or server? still not sure) and talk to my ruby program (which is operating as a server...) So... lets do that.</p>
<p>Here's the ruby I'm running:</p>
<pre><code>require 'pry'
require 'socket'

class HTTP
  attr_reader :server

  def initialize
    @server = TCPServer.new(9090)
  end

  puts "server's up, capiTAN"

  def receive_request_send_response
    while client = server.accept
      whole_response = []
      while line = client.gets and !line.chomp.empty?
        whole_response &lt;&lt; line
      end
      whole_response
    end

    output = "&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;holy what the fuck&lt;/body&gt;&lt;/html&gt;"

  end
end

p server = HTTP.new
p server.server
p server.receive_request_send_response</code></pre>
<p>When I run the ruby program, it just hangs. Which means it's stuck in <code>while client = server.accept</code>. When I run <code>curl -v localhost:9090</code> it too just sits and waits. Everyone is waiting for a response, but not even a header is sent, else <code>curl</code> would have shown </p>
<pre><code>&gt; header data
&gt; sent by
&gt; curl</code></pre>
<p>So, CURL doesn't have anything to send to. I wonder why.</p>
<p><code>nc</code> has an option. Checking out <code>tldr nc</code> the first option says:</p>
<blockquote>
<p>Connect to a certain port (you can then write to this port): nc ip_address port</p>
</blockquote>
<p>Good enough for me. </p>
<p><code>nc localhost 9090</code> doesn't do anything in either the ruby program or NC.</p>
<p>Lets try submitting a well-formatted HTTP request, and see what happens</p>
<p>I tried typing in exactly what CURL had sent last time:</p>
<pre><code>&gt; GET / HTTP/1.1
&gt; Host: localhost:9090
&gt; User-Agent: curl/7.52.1
&gt; Accept: */*</code></pre>
<p>and got nothing. but that's OK, cuz my program (right now) isn't showing me the captured HTTP request. Lets modify it to do that.</p>
<p>... </p>
<p>...</p>
<p>still trying to get this to work. Rolling back to a "known good" state w/my ruby program that captures server data.</p>
<p>Oh, worth noting:</p>
<p>if you see something that has this:</p>
<pre><code>GET / HTTP/1.1</code></pre>
<p>What is it? A request or a response?</p>
<p>How about this:</p>
<pre><code>HTTP/1.1 200 OK</code></pre>
<p>The first one is a <em>request</em>, the latter a <em>response</em>. I'm starting to not confuse them. </p>
<p>Boom, did it. First, I rolled back to the "server" we wrote as part of the tutorial I linked above.</p>
<pre><code>require 'socket'

tcp_server = TCPServer.new(9292)
client = tcp_server.accept

puts "ready for a request"

request_lines = []

while line = client.gets and !line.chomp.empty?
  request_lines &lt;&lt; line.chomp
end

puts "I (the server) just got this request:"
puts request_lines.inspect


puts "I (the server) am sending response."
response = "&lt;pre&gt;" + request_lines.join("\n") + "&lt;/pre&gt;"
output = response
headers = ["http/1.1 200 ok",
          "date: #{Time.now.strftime('%a, %e %b %Y %H:%M:%S %z')}",
          "server: ruby",
          "content-type: text/html; charset=iso-8859-1",
          "content-length: #{output.length}\r\n\r\n"].join("\r\n")
client.puts headers
client.puts output

puts ["Wrote this response:", headers, output].join("\n")
client.close
puts "\nResponse complete, exiting."</code></pre>
<p>I started that, and then in a different tab ran <code>nc localhost 9292</code> (please note I'm mixing up some port numbers here, so don't just copy/paste and expect any of this to work.)</p>
<p><img src="https://cl.ly/252a113I3B2A/1____turing_module1_projects_http_yeah_you_know_me_lib__bash_.jpg" alt="it's working!"></p>
<p>So, now the server will capture correctly-formatted HTTP requests and print them. Now lets build our own HTTP request in Netcat</p>
<p>Aww, yeah. Got it working. Check it out:</p>
<p><img src="https://cl.ly/171O3E1b3b3u/1____turing_module1_projects_http_yeah_you_know_me_lib__bash_.jpg" alt="built my own fake HTTP request"></p>
<p>I'm slowly (very slowly) building a mental map of what's going on behind the scenes, but this feels like a good realization. </p>
<h1 id="back-to-the-class-project-and-iteration-0">Back to the class project and iteration 0</h1>
<p>So we now know exactly what this is doing:</p>
<pre><code>while line = client.gets and !line.chomp.empty?
  request_lines &lt;&lt; line.chomp
end</code></pre>
<p>It's taking in header data from the client making the HTTP <em>request</em>, and ONLY header data. As soon as it gets a blank line (which is the universal sign for "end of header data") it stops adding new lines to the header data.</p>
<p>I'm restarting at Iteration 0, but this time putting everything in a class and methods. I'm not testing yet, that'll come later.</p>
<p>I've also not touched Faraday. ¯<em>(ツ)</em>/¯ </p>
<p>OK, got Iteration working, inside of a class: </p>
<pre><code>require 'pry'
require 'socket'

class HTTP
  attr_reader :server
  attr_accessor :client_response, :counter

  def initialize
    @server = TCPServer.new(9090)
    @client_response = []
    @counter = 0
  end

  # note to myself in terminal when this gets hit.
  puts "server's up, capiTAN"

  def send_message
    while client = server.accept
      while line = client.gets and !line.chomp.empty?
        client_response &lt;&lt; line = line.chomp
      end
        # assign a big block of text to a string with %{text}. New lines get \n auto-added
        output = %{&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
          #{client_response.join("\n")}
          this server has been (re)started #{counter} times
          &lt;/body&gt;&lt;/html&gt;\n}

        headers = [
          "HTTP/1.1 200 OK",
          "date = #{Time.now.strftime("%Y-%B-%d, %l:%M %P")}",
          "server: ruby",
          "content-type: text/html; charset=UTF-8",
          "content-length: #{output.length}",
          "\r\n"
        ]

      client.puts headers
      client.puts output
      @counter += 1
    end
  end
end

my_server = HTTP.new
my_server.send_message</code></pre>
<p>I can hit it in Postman or with CURL, and everything is expected. It's ugly, but damnit, it works.</p>
<h1 id="iteration-1">Iteration 1</h1>
<p>I'm thinking I just need to add the HTML </p>
<pre data-preserve-html-node="true"></pre>
<pre><code>require 'pry'
require 'socket'

class HTTP
  attr_reader :server
  attr_accessor :client_response, :counter

  def initialize
    @server = TCPServer.new(9090)
    @client_response = []
    @counter = 0
  end

  # note to myself in terminal when this gets hit.
  puts "server's up, capiTAN"

  def send_message
    while client = server.accept
      while line = client.gets and !line.chomp.empty?
        client_response &lt;&lt; line = line.chomp
      end
        # assign a big block of text to a string with %{text}. New lines get \n auto-added
        output = %{&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
          &lt;pre&gt;#{client_response.join("\n")}&lt;/pre&gt;
          this server has been (re)started #{counter} times
          &lt;/body&gt;&lt;/html&gt;\n}

        headers = [
          "HTTP/1.1 200 OK",
          "date = #{Time.now.strftime("%Y-%B-%d, %l:%M %P")}",
          "server: ruby",
          "content-type: text/html; charset=UTF-8",
          "content-length: #{output.length}",
          "\r\n"
        ]

      client.puts headers
      client.puts output
      @counter += 1
    end
  end
end

my_server = HTTP.new
my_server.send_message</code></pre>
<p>When I do this, my @client_response array gets longer... and longer... and longer. because everytime I reload the server I re-add new diagnostic info to it. So, lemme fix that. </p>
<p>Now, I'm having trouble getting the server to recognize the end of the header and the content. </p>
<p>The problem is with my new-line characters in my header response, I believe. </p>
<p>Editing my <code>headers</code> to:</p>
<pre><code>headers = ["HTTP/1.1 200 OK\r\n" +
          "date = #{Time.now.strftime("%Y-%B-%d, %l:%M %P")}\r\n" +
          "server: ruby\r\n" +
          "content-type: text/html; charset=UTF-8" +
          "content-length: #{output.length}" +
          "\r\n\r\n"
        ]</code></pre>
<p>and we're almost back in action. Here's the CURL output:</p>
<pre><code>[http_yeah_you_know_me (setup)]$ curl -v localhost:9090
* Rebuilt URL to: localhost:9090/
*   Trying ::1...
* TCP_NODELAY set
* Connection failed
* connect to ::1 port 9090 failed: Connection refused
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 9090 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:9090
&gt; User-Agent: curl/7.52.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; date = 2017-February-14,  5:22 pm
&lt; server: ruby
&lt; content-type: text/html; charset=UTF-8content-length: 215
* no chunk, no close, no size. Assume close to signal end
&lt;

          &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
          &lt;pre&gt;GET / HTTP/1.1
Host: localhost:9090
User-Agent: curl/7.52.1
Accept: */*&lt;/pre&gt;
          this server has been (re)started 0 times
          &lt;/body&gt;&lt;/html&gt;</code></pre>
<p>It thinks the content ended before the last line. (see how <code>content-length: 215</code> is directly following <code>content-type</code>? lets add an <code>\r\n</code> to the end of that line in my Header output.</p>
<p>updated <code>headers</code> to:</p>
<pre><code>headers = ["HTTP/1.1 200 OK\r\n" +
          "date = #{Time.now.strftime("%Y-%B-%d, %l:%M %P")}\r\n" +
          "server: ruby\r\n" +
          "content-type: text/html; charset=UTF-8\r\n" +
          "content-length: #{output.length}\r\n" +
          "\r\n"
        ]</code></pre>
<p>and it works! Iteration 1 done. </p>
<h1 id="iteration-2-supporting-paths">Iteration 2: supporting paths</h1>
<p>well eff, my existing code is so horrible path support is a major PITA. </p>
<p>Part of the problem is I cannot easily calculate my output length, so building my response, I cannot tell the server (easily) how many characters to expect. </p>
<p>Time for some refactoring, I guess.</p>
<p>I'm going to try to clean up my http response block. Here's what I've got:</p>
<pre><code>helloworld_path = ["&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;" +
        "hello world, this has been reloaded #{counter} times." +
        "&lt;/body&gt;&lt;/html&gt;"]

      @counter += 1

      default_path = ["&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\r\n" +
        "&lt;pre&gt;#{client_response.join("\n")}&lt;/pre&gt;\r\n" +
        "this server has been (re)started #{counter} times\r\n" +
        "&lt;/body&gt;&lt;/html&gt;\n"
      ]

      headers = ["HTTP/1.1 200 OK\r\n" +
        "date = #{Time.now.strftime("%Y-%B-%d, %l:%M %P")}\r\n" +
        "server: ruby\r\n" +
        "content-type: text/html; charset=UTF-8\r\n" +
        "content-length: #{helloworld_path.join.length}\r\n" +
        "connection: close" +
        "\r\n\r\n"
      ]
      client.puts headers</code></pre>
<p>notice I've hard-coded "helloworld_path". That's because trying to add path support revealed this little problem to me.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>It's a PITA, but... a few hours of work after ^^, I sorted it out. There's a few pieces in play:</p>
<ol>
<li>Pulling data from the GET request (like path)</li>
<li>building the FRAME if the server response. Hardcode some pieces, use variables for the stuff that changes</li>
<li>Build variables that hold the variable parts of the response. (seems obvious, right? That's why I wanna smash through my desk with my head.)</li>
</ol>
<p>I'll add comments to the following code. This mostly handles iteration 2:</p>
<pre><code>def send_message

    # client_response holds all the received data, like `GET / HTTP/1.1`. The / is of particular interest.
    client_response = []
    while client = server.accept
      while line = client.gets and !line.chomp.empty?
        client_response &lt;&lt; line = line.chomp
      end
      # ^^ end of building the client response

      # pulling out the path, be it /, or /hello, or /datetime, etc.
      path = client_response[0].split[1]

      # building variables to insert into my HTTP response block later

      time = Time.now.strftime("%Y %B %d, %H:%M %z")

      # possible responses based on path
      hello_path = ["hello world, this has been reloaded #{counter} times."]
      default_path = ["&lt;pre&gt;#{Time.now}\nThis is my default path&lt;/pre&gt;\r\n"]
      datetime_path = ["&lt;pre&gt;The time is #{time}&lt;/pre&gt;"]
      shutdown_path = ["Total requests: #{counter}\nExiting..."]

      if path == "/"
        response = default_path
      elsif path == "/hello"
        response = hello_path
      elsif path == "/datetime"
        response = datetime_path
      elsif path == "/shutdown"
        response = shutdown_path
      end

      # building the server response. It'll always get wrapped the the following HTML. the `join` method fixes the fact that the parameters are currently wrapped in brackets. example: hello_path = ["some string here"])
      output = "&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;#{response.join}&lt;/body&gt;&lt;/html&gt;"

      # this is the fixed part of the server response. Every response will be the same, except the date changes to be Time.now, and output.length MUST be accurate, or the server will either not print the full request, or it'll hang after all the data is received, because it's expecting more.
      headers = ["http/1.1 200 ok",
                "date: #{time}",
                "server: ruby",
                "content-type: text/html; charset=iso-8859-1",
                "content-length: #{output.length + 1}\r\n\r\n"].join("\r\n")

      # incrementing my counter
      @counter += 1

      # client.puts is the _sending_ actual response to the server. Headers is distinct from the output.
      client.puts headers
      client.puts output

      # this stuff is sorta ugly random shit to reset the values so when I reload the page, it'll accept different paths. I am 100% sure this is not best practice.
      client.close

      # I couldn't get my shutdown method to sit neatly in one if statement. ¯\_(ツ)_/¯
      client.exit if path == "/shutdown"
      # resetting values for next connection
      response = nil
      path = nil
      client_response = []
    end


  end
end

my_server = HTTP.new
my_server.send_message</code></pre>
<h2 id="iteration-3-supporting-params">Iteration 3: supporting params</h2>
<p>Given a sample paramter like </p>
<pre><code>http://host:port/path?param=value&amp;param2=value2</code></pre>
<p>how can we pull the parameters? That will be the first step to doing something with them. I don't care how I store them for now.</p>
<p>I think I can pull everything following the <code>?</code> using a REGEX match or split or something.</p>
<p>lets play around in pry with the string. </p>
<pre><code>string = "http://host:port/path?param=value&amp;param2=value"

# eff, so confused.

# ok, I used this:

path = client_response[0].split[1]
word_search = path.split("=")[1]</code></pre>
<p>here's the output from pry:</p>
<pre><code>path                 ... "/word_search?word=house"
response             ... nil
shutdown_path        ... nil
time                 ... nil
word_search          ... "house"</code></pre>
</body></html>
